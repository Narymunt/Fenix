
#include "GLTextureHelper.h"
#include <QuartzCore/QuartzCore.h>
#include <Foundation/NSBundle.h>
#include <UIKit/UIKit.h>
#include <UIKit/UIImage.h>

#include "KMiscTools.h"


GLTextureHelper::GLTextureHelper()
{
	_pData = NULL;
	_eyeRetina = false;
}

GLTextureHelper::~GLTextureHelper(void)
{
	if(_pData) {
		free(_pData);
		_pData = NULL;
	}
}

void GLTextureHelper::clearSurface(char * surface, int w, int h, int bpp, int R, int G, int B, int A)
{
	int pixelSize = bpp/8;
	for(int i=0 ; i<w ; i++)
	{
		for(int j=0 ; j<h ; j++)
		{
			int pos = (i + (w * j))*pixelSize;
			if(pixelSize == 3)
			{
				surface[pos+0] = R;
				surface[pos+1] = G;
				surface[pos+2] = B;
			}
			else if(pixelSize == 4)
			{
				surface[pos+0] = R;
				surface[pos+1] = G;
				surface[pos+2] = B;
				surface[pos+3] = A;
			}
		}		
	}	
}

bool GLTextureHelper::LoadWatermark()
{
	CGImageRef Image;
	CGContextRef Context;
	long   v;
	int rx = 1;
	int ry = 1;
	const char bytes[] = "\x89\x50\x4E\x47\x0D\x0A\x1A\x0A\x00\x00\x00\x0D\x49\x48\x44\x52\x00\x00\x00\x50\x00\x00\x00\x21\x08\x06\x00\x00\x00\x4E\x6F\x2C\xC9\x00\x00\x00\x09\x70\x48\x59\x73\x00\x00\x0A\xF0\x00\x00\x0A\xF0\x01\x42\xAC\x34\x98\x00\x00\x0A\x4F\x69\x43\x43\x50\x50\x68\x6F\x74\x6F\x73\x68\x6F\x70\x20\x49\x43\x43\x20\x70\x72\x6F\x66\x69\x6C\x65\x00\x00\x78\xDA\x9D\x53\x67\x54\x53\xE9\x16\x3D\xF7\xDE\xF4\x42\x4B\x88\x80\x94\x4B\x6F\x52\x15\x08\x20\x52\x42\x8B\x80\x14\x91\x26\x2A\x21\x09\x10\x4A\x88\x21\xA1\xD9\x15\x51\xC1\x11\x45\x45\x04\x1B\xC8\xA0\x88\x03\x8E\x8E\x80\x8C\x15\x51\x2C\x0C\x8A\x0A\xD8\x07\xE4\x21\xA2\x8E\x83\xA3\x88\x8A\xCA\xFB\xE1\x7B\xA3\x6B\xD6\xBC\xF7\xE6\xCD\xFE\xB5\xD7\x3E\xE7\xAC\xF3\x9D\xB3\xCF\x07\xC0\x08\x0C\x96\x48\x33\x51\x35\x80\x0C\xA9\x42\x1E\x11\xE0\x83\xC7\xC4\xC6\xE1\xE4\x2E\x40\x81\x0A\x24\x70\x00\x10\x08\xB3\x64\x21\x73\xFD\x23\x01\x00\xF8\x7E\x3C\x3C\x2B\x22\xC0\x07\xBE\x00\x01\x78\xD3\x0B\x08\x00\xC0\x4D\x9B\xC0\x30\x1C\x87\xFF\x0F\xEA\x42\x99\x5C\x01\x80\x84\x01\xC0\x74\x91\x38\x4B\x08\x80\x14\x00\x40\x7A\x8E\x42\xA6\x00\x40\x46\x01\x80\x9D\x98\x26\x53\x00\xA0\x04\x00\x60\xCB\x63\x62\xE3\x00\x50\x2D\x00\x60\x27\x7F\xE6\xD3\x00\x80\x9D\xF8\x99\x7B\x01\x00\x5B\x94\x21\x15\x01\xA0\x91\x00\x20\x13\x65\x88\x44\x00\x68\x3B\x00\xAC\xCF\x56\x8A\x45\x00\x58\x30\x00\x14\x66\x4B\xC4\x39\x00\xD8\x2D\x00\x30\x49\x57\x66\x48\x00\xB0\xB7\x00\xC0\xCE\x10\x0B\xB2\x00\x08\x0C\x00\x30\x51\x88\x85\x29\x00\x04\x7B\x00\x60\xC8\x23\x23\x78\x00\x84\x99\x00\x14\x46\xF2\x57\x3C\xF1\x2B\xAE\x10\xE7\x2A\x00\x00\x78\x99\xB2\x3C\xB9\x24\x39\x45\x81\x5B\x08\x2D\x71\x07\x57\x57\x2E\x1E\x28\xCE\x49\x17\x2B\x14\x36\x61\x02\x61\x9A\x40\x2E\xC2\x79\x99\x19\x32\x81\x34\x0F\xE0\xF3\xCC\x00\x00\xA0\x91\x15\x11\xE0\x83\xF3\xFD\x78\xCE\x0E\xAE\xCE\xCE\x36\x8E\xB6\x0E\x5F\x2D\xEA\xBF\x06\xFF\x22\x62\x62\xE3\xFE\xE5\xCF\xAB\x70\x40\x00\x00\xE1\x74\x7E\xD1\xFE\x2C\x2F\xB3\x1A\x80\x3B\x06\x80\x6D\xFE\xA2\x25\xEE\x04\x68\x5E\x0B\xA0\x75\xF7\x8B\x66\xB2\x0F\x40\xB5\x00\xA0\xE9\xDA\x57\xF3\x70\xF8\x7E\x3C\x3C\x45\xA1\x90\xB9\xD9\xD9\xE5\xE4\xE4\xD8\x4A\xC4\x42\x5B\x61\xCA\x57\x7D\xFE\x67\xC2\x5F\xC0\x57\xFD\x6C\xF9\x7E\x3C\xFC\xF7\xF5\xE0\xBE\xE2\x24\x81\x32\x5D\x81\x47\x04\xF8\xE0\xC2\xCC\xF4\x4C\xA5\x1C\xCF\x92\x09\x84\x62\xDC\xE6\x8F\x47\xFC\xB7\x0B\xFF\xFC\x1D\xD3\x22\xC4\x49\x62\xB9\x58\x2A\x14\xE3\x51\x12\x71\x8E\x44\x9A\x8C\xF3\x32\xA5\x22\x89\x42\x92\x29\xC5\x25\xD2\xFF\x64\xE2\xDF\x2C\xFB\x03\x3E\xDF\x35\x00\xB0\x6A\x3E\x01\x7B\x91\x2D\xA8\x5D\x63\x03\xF6\x4B\x27\x10\x58\x74\xC0\xE2\xF7\x00\x00\xF2\xBB\x6F\xC1\xD4\x28\x08\x03\x80\x68\x83\xE1\xCF\x77\xFF\xEF\x3F\xFD\x47\xA0\x25\x00\x80\x66\x49\x92\x71\x00\x00\x5E\x44\x24\x2E\x54\xCA\xB3\x3F\xC7\x08\x00\x00\x44\xA0\x81\x2A\xB0\x41\x1B\xF4\xC1\x18\x2C\xC0\x06\x1C\xC1\x05\xDC\xC1\x0B\xFC\x60\x36\x84\x42\x24\xC4\xC2\x42\x10\x42\x0A\x64\x80\x1C\x72\x60\x29\xAC\x82\x42\x28\x86\xCD\xB0\x1D\x2A\x60\x2F\xD4\x40\x1D\x34\xC0\x51\x68\x86\x93\x70\x0E\x2E\xC2\x55\xB8\x0E\x3D\x70\x0F\xFA\x61\x08\x9E\xC1\x28\xBC\x81\x09\x04\x41\xC8\x08\x13\x61\x21\xDA\x88\x01\x62\x8A\x58\x23\x8E\x08\x17\x99\x85\xF8\x21\xC1\x48\x04\x12\x8B\x24\x20\xC9\x88\x14\x51\x22\x4B\x91\x35\x48\x31\x52\x8A\x54\x20\x55\x48\x1D\xF2\x3D\x72\x02\x39\x87\x5C\x46\xBA\x91\x3B\xC8\x00\x32\x82\xFC\x86\xBC\x47\x31\x94\x81\xB2\x51\x3D\xD4\x0C\xB5\x43\xB9\xA8\x37\x1A\x84\x46\xA2\x0B\xD0\x64\x74\x31\x9A\x8F\x16\xA0\x9B\xD0\x72\xB4\x1A\x3D\x8C\x36\xA1\xE7\xD0\xAB\x68\x0F\xDA\x8F\x3E\x43\xC7\x30\xC0\xE8\x18\x07\x33\xC4\x6C\x30\x2E\xC6\xC3\x42\xB1\x38\x2C\x09\x93\x63\xCB\xB1\x22\xAC\x0C\xAB\xC6\x1A\xB0\x56\xAC\x03\xBB\x89\xF5\x63\xCF\xB1\x77\x04\x12\x81\x45\xC0\x09\x36\x04\x77\x42\x20\x61\x1E\x41\x48\x58\x4C\x58\x4E\xD8\x48\xA8\x20\x1C\x24\x34\x11\xDA\x09\x37\x09\x03\x84\x51\xC2\x27\x22\x93\xA8\x4B\xB4\x26\xBA\x11\xF9\xC4\x18\x62\x32\x31\x87\x58\x48\x2C\x23\xD6\x12\x8F\x13\x2F\x10\x7B\x88\x43\xC4\x37\x24\x12\x89\x43\x32\x27\xB9\x90\x02\x49\xB1\xA4\x54\xD2\x12\xD2\x46\xD2\x6E\x52\x23\xE9\x2C\xA9\x9B\x34\x48\x1A\x23\x93\xC9\xDA\x64\x6B\xB2\x07\x39\x94\x2C\x20\x2B\xC8\x85\xE4\x9D\xE4\xC3\xE4\x33\xE4\x1B\xE4\x21\xF2\x5B\x0A\x9D\x62\x40\x71\xA4\xF8\x53\xE2\x28\x52\xCA\x6A\x4A\x19\xE5\x10\xE5\x34\xE5\x06\x65\x98\x32\x41\x55\xA3\x9A\x52\xDD\xA8\xA1\x54\x11\x35\x8F\x5A\x42\xAD\xA1\xB6\x52\xAF\x51\x87\xA8\x13\x34\x75\x9A\x39\xCD\x83\x16\x49\x4B\xA5\xAD\xA2\x95\xD3\x1A\x68\x17\x68\xF7\x69\xAF\xE8\x74\xBA\x11\xDD\x95\x1E\x4E\x97\xD0\x57\xD2\xCB\xE9\x47\xE8\x97\xE8\x03\xF4\x77\x0C\x0D\x86\x15\x83\xC7\x88\x67\x28\x19\x9B\x18\x07\x18\x67\x19\x77\x18\xAF\x98\x4C\xA6\x19\xD3\x8B\x19\xC7\x54\x30\x37\x31\xEB\x98\xE7\x99\x0F\x99\x6F\x55\x58\x2A\xB6\x2A\x7C\x15\x91\xCA\x0A\x95\x4A\x95\x26\x95\x1B\x2A\x2F\x54\xA9\xAA\xA6\xAA\xDE\xAA\x0B\x55\xF3\x55\xCB\x54\x8F\xA9\x5E\x53\x7D\xAE\x46\x55\x33\x53\xE3\xA9\x09\xD4\x96\xAB\x55\xAA\x9D\x50\xEB\x53\x1B\x53\x67\xA9\x3B\xA8\x87\xAA\x67\xA8\x6F\x54\x3F\xA4\x7E\x59\xFD\x89\x06\x59\xC3\x4C\xC3\x4F\x43\xA4\x51\xA0\xB1\x5F\xE3\xBC\xC6\x20\x0B\x63\x19\xB3\x78\x2C\x21\x6B\x0D\xAB\x86\x75\x81\x35\xC4\x26\xB1\xCD\xD9\x7C\x76\x2A\xBB\x98\xFD\x1D\xBB\x8B\x3D\xAA\xA9\xA1\x39\x43\x33\x4A\x33\x57\xB3\x52\xF3\x94\x66\x3F\x07\xE3\x98\x71\xF8\x9C\x74\x4E\x09\xE7\x28\xA7\x97\xF3\x7E\x8A\xDE\x14\xEF\x29\xE2\x29\x1B\xA6\x34\x4C\xB9\x31\x65\x5C\x6B\xAA\x96\x97\x96\x58\xAB\x48\xAB\x51\xAB\x47\xEB\xBD\x36\xAE\xED\xA7\x9D\xA6\xBD\x45\xBB\x59\xFB\x81\x0E\x41\xC7\x4A\x27\x5C\x27\x47\x67\x8F\xCE\x05\x9D\xE7\x53\xD9\x53\xDD\xA7\x0A\xA7\x16\x4D\x3D\x3A\xF5\xAE\x2E\xAA\x6B\xA5\x1B\xA1\xBB\x44\x77\xBF\x6E\xA7\xEE\x98\x9E\xBE\x5E\x80\x9E\x4C\x6F\xA7\xDE\x79\xBD\xE7\xFA\x1C\x7D\x2F\xFD\x54\xFD\x6D\xFA\xA7\xF5\x47\x0C\x58\x06\xB3\x0C\x24\x06\xDB\x0C\xCE\x18\x3C\xC5\x35\x71\x6F\x3C\x1D\x2F\xC7\xDB\xF1\x51\x43\x5D\xC3\x40\x43\xA5\x61\x95\x61\x97\xE1\x84\x91\xB9\xD1\x3C\xA3\xD5\x46\x8D\x46\x0F\x8C\x69\xC6\x5C\xE3\x24\xE3\x6D\xC6\x6D\xC6\xA3\x26\x06\x26\x21\x26\x4B\x4D\xEA\x4D\xEE\x9A\x52\x4D\xB9\xA6\x29\xA6\x3B\x4C\x3B\x4C\xC7\xCD\xCC\xCD\xA2\xCD\xD6\x99\x35\x9B\x3D\x31\xD7\x32\xE7\x9B\xE7\x9B\xD7\x9B\xDF\xB7\x60\x5A\x78\x5A\x2C\xB6\xA8\xB6\xB8\x65\x49\xB2\xE4\x5A\xA6\x59\xEE\xB6\xBC\x6E\x85\x5A\x39\x59\xA5\x58\x55\x5A\x5D\xB3\x46\xAD\x9D\xAD\x25\xD6\xBB\xAD\xBB\xA7\x11\xA7\xB9\x4E\x93\x4E\xAB\x9E\xD6\x67\xC3\xB0\xF1\xB6\xC9\xB6\xA9\xB7\x19\xB0\xE5\xD8\x06\xDB\xAE\xB6\x6D\xB6\x7D\x61\x67\x62\x17\x67\xB7\xC5\xAE\xC3\xEE\x93\xBD\x93\x7D\xBA\x7D\x8D\xFD\x3D\x07\x0D\x87\xD9\x0E\xAB\x1D\x5A\x1D\x7E\x73\xB4\x72\x14\x3A\x56\x3A\xDE\x9A\xCE\x9C\xEE\x3F\x7D\xC5\xF4\x96\xE9\x2F\x67\x58\xCF\x10\xCF\xD8\x33\xE3\xB6\x13\xCB\x29\xC4\x69\x9D\x53\x9B\xD3\x47\x67\x17\x67\xB9\x73\x83\xF3\x88\x8B\x89\x4B\x82\xCB\x2E\x97\x3E\x2E\x9B\x1B\xC6\xDD\xC8\xBD\xE4\x4A\x74\xF5\x71\x5D\xE1\x7A\xD2\xF5\x9D\x9B\xB3\x9B\xC2\xED\xA8\xDB\xAF\xEE\x36\xEE\x69\xEE\x87\xDC\x9F\xCC\x34\x9F\x29\x9E\x59\x33\x73\xD0\xC3\xC8\x43\xE0\x51\xE5\xD1\x3F\x0B\x9F\x95\x30\x6B\xDF\xAC\x7E\x4F\x43\x4F\x81\x67\xB5\xE7\x23\x2F\x63\x2F\x91\x57\xAD\xD7\xB0\xB7\xA5\x77\xAA\xF7\x61\xEF\x17\x3E\xF6\x3E\x72\x9F\xE3\x3E\xE3\x3C\x37\xDE\x32\xDE\x59\x5F\xCC\x37\xC0\xB7\xC8\xB7\xCB\x4F\xC3\x6F\x9E\x5F\x85\xDF\x43\x7F\x23\xFF\x64\xFF\x7A\xFF\xD1\x00\xA7\x80\x25\x01\x67\x03\x89\x81\x41\x81\x5B\x02\xFB\xF8\x7A\x7C\x21\xBF\x8E\x3F\x3A\xDB\x65\xF6\xB2\xD9\xED\x41\x8C\xA0\xB9\x41\x15\x41\x8F\x82\xAD\x82\xE5\xC1\xAD\x21\x68\xC8\xEC\x90\xAD\x21\xF7\xE7\x98\xCE\x91\xCE\x69\x0E\x85\x50\x7E\xE8\xD6\xD0\x07\x61\xE6\x61\x8B\xC3\x7E\x0C\x27\x85\x87\x85\x57\x86\x3F\x8E\x70\x88\x58\x1A\xD1\x31\x97\x35\x77\xD1\xDC\x43\x73\xDF\x44\xFA\x44\x96\x44\xDE\x9B\x67\x31\x4F\x39\xAF\x2D\x4A\x35\x2A\x3E\xAA\x2E\x6A\x3C\xDA\x37\xBA\x34\xBA\x3F\xC6\x2E\x66\x59\xCC\xD5\x58\x9D\x58\x49\x6C\x4B\x1C\x39\x2E\x2A\xAE\x36\x6E\x6C\xBE\xDF\xFC\xED\xF3\x87\xE2\x9D\xE2\x0B\xE3\x7B\x17\x98\x2F\xC8\x5D\x70\x79\xA1\xCE\xC2\xF4\x85\xA7\x16\xA9\x2E\x12\x2C\x3A\x96\x40\x4C\x88\x4E\x38\x94\xF0\x41\x10\x2A\xA8\x16\x8C\x25\xF2\x13\x77\x25\x8E\x0A\x79\xC2\x1D\xC2\x67\x22\x2F\xD1\x36\xD1\x88\xD8\x43\x5C\x2A\x1E\x4E\xF2\x48\x2A\x4D\x7A\x92\xEC\x91\xBC\x35\x79\x24\xC5\x33\xA5\x2C\xE5\xB9\x84\x27\xA9\x90\xBC\x4C\x0D\x4C\xDD\x9B\x3A\x9E\x16\x9A\x76\x20\x6D\x32\x3D\x3A\xBD\x31\x83\x92\x91\x90\x71\x42\xAA\x21\x4D\x93\xB6\x67\xEA\x67\xE6\x66\x76\xCB\xAC\x65\x85\xB2\xFE\xC5\x6E\x8B\xB7\x2F\x1E\x95\x07\xC9\x6B\xB3\x90\xAC\x05\x59\x2D\x0A\xB6\x42\xA6\xE8\x54\x5A\x28\xD7\x2A\x07\xB2\x67\x65\x57\x66\xBF\xCD\x89\xCA\x39\x96\xAB\x9E\x2B\xCD\xED\xCC\xB3\xCA\xDB\x90\x37\x9C\xEF\x9F\xFF\xED\x12\xC2\x12\xE1\x92\xB6\xA5\x86\x4B\x57\x2D\x1D\x58\xE6\xBD\xAC\x6A\x39\xB2\x3C\x71\x79\xDB\x0A\xE3\x15\x05\x2B\x86\x56\x06\xAC\x3C\xB8\x8A\xB6\x2A\x6D\xD5\x4F\xAB\xED\x57\x97\xAE\x7E\xBD\x26\x7A\x4D\x6B\x81\x5E\xC1\xCA\x82\xC1\xB5\x01\x6B\xEB\x0B\x55\x0A\xE5\x85\x7D\xEB\xDC\xD7\xED\x5D\x4F\x58\x2F\x59\xDF\xB5\x61\xFA\x86\x9D\x1B\x3E\x15\x89\x8A\xAE\x14\xDB\x17\x97\x15\x7F\xD8\x28\xDC\x78\xE5\x1B\x87\x6F\xCA\xBF\x99\xDC\x94\xB4\xA9\xAB\xC4\xB9\x64\xCF\x66\xD2\x66\xE9\xE6\xDE\x2D\x9E\x5B\x0E\x96\xAA\x97\xE6\x97\x0E\x6E\x0D\xD9\xDA\xB4\x0D\xDF\x56\xB4\xED\xF5\xF6\x45\xDB\x2F\x97\xCD\x28\xDB\xBB\x83\xB6\x43\xB9\xA3\xBF\x3C\xB8\xBC\x65\xA7\xC9\xCE\xCD\x3B\x3F\x54\xA4\x54\xF4\x54\xFA\x54\x36\xEE\xD2\xDD\xB5\x61\xD7\xF8\x6E\xD1\xEE\x1B\x7B\xBC\xF6\x34\xEC\xD5\xDB\x5B\xBC\xF7\xFD\x3E\xC9\xBE\xDB\x55\x01\x55\x4D\xD5\x66\xD5\x65\xFB\x49\xFB\xB3\xF7\x3F\xAE\x89\xAA\xE9\xF8\x96\xFB\x6D\x5D\xAD\x4E\x6D\x71\xED\xC7\x03\xD2\x03\xFD\x07\x23\x0E\xB6\xD7\xB9\xD4\xD5\x1D\xD2\x3D\x54\x52\x8F\xD6\x2B\xEB\x47\x0E\xC7\x1F\xBE\xFE\x9D\xEF\x77\x2D\x0D\x36\x0D\x55\x8D\x9C\xC6\xE2\x23\x70\x44\x79\xE4\xE9\xF7\x09\xDF\xF7\x1E\x0D\x3A\xDA\x76\x8C\x7B\xAC\xE1\x07\xD3\x1F\x76\x1D\x67\x1D\x2F\x6A\x42\x9A\xF2\x9A\x46\x9B\x53\x9A\xFB\x5B\x62\x5B\xBA\x4F\xCC\x3E\xD1\xD6\xEA\xDE\x7A\xFC\x47\xDB\x1F\x0F\x9C\x34\x3C\x59\x79\x4A\xF3\x54\xC9\x69\xDA\xE9\x82\xD3\x93\x67\xF2\xCF\x8C\x9D\x95\x9D\x7D\x7E\x2E\xF9\xDC\x60\xDB\xA2\xB6\x7B\xE7\x63\xCE\xDF\x6A\x0F\x6F\xEF\xBA\x10\x74\xE1\xD2\x45\xFF\x8B\xE7\x3B\xBC\x3B\xCE\x5C\xF2\xB8\x74\xF2\xB2\xDB\xE5\x13\x57\xB8\x57\x9A\xAF\x3A\x5F\x6D\xEA\x74\xEA\x3C\xFE\x93\xD3\x4F\xC7\xBB\x9C\xBB\x9A\xAE\xB9\x5C\x6B\xB9\xEE\x7A\xBD\xB5\x7B\x66\xF7\xE9\x1B\x9E\x37\xCE\xDD\xF4\xBD\x79\xF1\x16\xFF\xD6\xD5\x9E\x39\x3D\xDD\xBD\xF3\x7A\x6F\xF7\xC5\xF7\xF5\xDF\x16\xDD\x7E\x72\x27\xFD\xCE\xCB\xBB\xD9\x77\x27\xEE\xAD\xBC\x4F\xBC\x5F\xF4\x40\xED\x41\xD9\x43\xDD\x87\xD5\x3F\x5B\xFE\xDC\xD8\xEF\xDC\x7F\x6A\xC0\x77\xA0\xF3\xD1\xDC\x47\xF7\x06\x85\x83\xCF\xFE\x91\xF5\x8F\x0F\x43\x05\x8F\x99\x8F\xCB\x86\x0D\x86\xEB\x9E\x38\x3E\x39\x39\xE2\x3F\x72\xFD\xE9\xFC\xA7\x43\xCF\x64\xCF\x26\x9E\x17\xFE\xA2\xFE\xCB\xAE\x17\x16\x2F\x7E\xF8\xD5\xEB\xD7\xCE\xD1\x98\xD1\xA1\x97\xF2\x97\x93\xBF\x6D\x7C\xA5\xFD\xEA\xC0\xEB\x19\xAF\xDB\xC6\xC2\xC6\x1E\xBE\xC9\x78\x33\x31\x5E\xF4\x56\xFB\xED\xC1\x77\xDC\x77\x1D\xEF\xA3\xDF\x0F\x4F\xE4\x7C\x20\x7F\x28\xFF\x68\xF9\xB1\xF5\x53\xD0\xA7\xFB\x93\x19\x93\x93\xFF\x04\x03\x98\xF3\xFC\x63\x33\x2D\xDB\x00\x00\x00\x20\x63\x48\x52\x4D\x00\x00\x7A\x25\x00\x00\x80\x83\x00\x00\xF9\xFF\x00\x00\x80\xE9\x00\x00\x75\x30\x00\x00\xEA\x60\x00\x00\x3A\x98\x00\x00\x17\x6F\x92\x5F\xC5\x46\x00\x00\x0B\x62\x49\x44\x41\x54\x78\xDA\xEC\x99\x5D\x8C\x5D\xD7\x55\xC7\x7F\x6B\x9F\x73\xEE\xE7\xCC\x9D\x19\xCF\x78\x3C\xCE\x98\xB1\x1D\xDB\x4D\x9D\x28\xB6\xCC\x04\x4A\x20\x21\x40\x51\xD4\xD6\xA6\x10\x88\x4A\x0A\x6A\xAA\xD2\xA6\xCA\x4B\xCB\x03\xB4\x12\x12\x12\x12\xA9\x10\x08\x44\xE1\x01\xF5\x05\x21\x45\x15\x14\x44\x85\xAA\x2A\x52\x1B\x51\xB5\x4A\x45\x11\x2A\x99\x1A\xD7\x8D\x55\xD7\xB5\x1D\x3B\xB1\xE3\x71\xEC\x99\xB9\x5F\xE7\x73\xEF\xBD\x78\x98\x73\x9D\x9B\xD1\x8C\xBF\x32\x58\x54\xF2\x91\x96\xB4\xCF\xB9\x6B\xEF\xB3\xCF\x7F\xFF\xD7\x5A\xFF\xBD\xAF\xA8\x2A\x77\xAF\xDB\xBF\xCC\x5D\x08\xEE\x02\x78\x17\xC0\xBB\x00\xDE\x05\xF0\xEE\x75\xBB\x57\x38\x68\x2C\x2C\x2C\xBC\xED\x87\x8A\x81\xB3\x7D\xC3\x1F\x9D\x68\xA0\x80\x6C\x30\x80\x57\x82\xCC\xF9\xFD\xDB\x9B\xD1\x4F\xBF\x7B\xAA\xBA\x2B\x10\x5A\xAF\x75\x6D\xBE\xD8\x2B\xCE\xF6\x0B\xFF\x1D\x85\x13\x91\x79\x7B\x6F\x2D\x47\x7B\xA2\xFF\x12\x53\x76\x09\x53\xA9\x71\xFF\xFE\xFB\x09\x82\x80\x24\x4D\x88\xE3\x98\xF3\xE7\xCF\x23\x22\xD4\x6A\x35\x9C\x73\xD4\x6A\x35\x00\x92\x24\xC1\x5A\xCB\x40\x3D\x88\x08\x51\x18\x12\x46\x11\x3B\x66\x67\xF1\x5E\x59\x5A\x5E\xA2\x5E\xAF\x33\x31\x3E\x8E\x73\x8E\xAB\x4B\x4B\xA8\x2A\x45\x51\x60\xAD\x65\x74\x64\x84\x2D\x5B\x26\x49\xD3\x94\x2C\x4B\x89\xA2\x88\x7E\x1C\x93\xA6\x29\xCF\x3C\xF3\xCC\xED\x01\x78\x3B\xEC\x75\x5E\x1F\x37\x46\x3E\xF4\xC4\xBB\xC6\xF6\x7E\xF4\xC0\x16\xA6\x9B\x01\x20\x24\xD6\xB3\xF0\x46\xF2\xC8\x7F\x5D\xE8\x7F\xE4\xD8\x62\xFA\x1F\xE7\x3B\xF9\xDF\x04\x46\x2E\xCB\x1D\x60\x84\x52\xCA\x32\x55\xB4\xB4\x3B\xC2\xC0\x5B\x9A\xA4\xB2\x23\xB5\xFA\x99\x56\xD5\x1C\x3A\xB2\x6F\x94\x8F\x1D\xD8\x42\x2D\x34\xC4\xB9\xA2\x28\x81\x81\x07\xA7\x6B\xBC\x19\x17\x6C\x6B\x84\x8F\x7C\x6F\x31\xD9\x73\x74\x31\xF9\xAC\x11\x39\x27\xE5\x67\x0E\x38\xBD\xD9\xA0\x8A\x08\xC6\x18\xC4\x98\xD9\x30\x0C\x77\x88\x48\x21\x22\x27\x80\xD4\x18\x73\xED\xED\x77\x04\x40\x5D\xE7\x65\xAA\x1C\x14\xE1\xB9\x07\xA7\x6B\xE3\xF7\x4F\x55\x19\xAB\x06\x24\x56\x51\xF5\xB8\xD2\xD9\x29\xA8\xC2\x4A\xEA\xE9\xE6\x8E\x77\x4F\x56\xB7\xF7\x0B\xFF\x27\x27\xAF\x66\x9F\x0A\x8D\xF4\x87\x61\xD3\x9B\x01\xF1\x26\x59\xE4\xBD\x32\x32\x32\x82\x7A\xA5\xD5\x1A\xFD\xF5\xB9\xB9\xB9\xA7\x8A\xA2\xB0\xD6\xB9\x8F\xA3\x9C\xBD\xBA\x74\x15\xEF\xFD\xA6\x2E\x9A\xB9\x1E\x78\xA1\x81\x40\xC0\xBF\x35\xFF\x07\xAC\xEA\x9F\xFF\xF6\xFE\xF1\xF1\xCF\x3D\x36\xC3\x87\x1F\x18\xA7\x97\x7B\xBE\x7B\x31\x46\x81\xC0\x80\x91\x55\x3B\xB6\x98\x70\xA1\x5B\xD0\xC9\x3D\x57\x13\xC7\xEC\x48\xB4\xB7\x19\x99\xDF\xF5\x0A\x1E\x61\xD4\xF7\x69\xF9\x3E\x5E\x0C\x40\x00\xB4\x80\x16\x4A\x55\x44\x10\x11\xBC\xF7\x38\xE7\x42\x13\x04\x53\x20\x2D\xEF\x9C\xAC\x17\x92\xAA\x8A\x77\x0E\x45\x6B\xC6\x98\x66\x9C\xC4\xE4\x45\xA1\x45\x9E\x53\xE4\x39\xEA\xBD\xE6\x45\x4E\xBB\xDD\x5E\xF5\x55\x35\xA0\x23\x8A\x56\xBC\xFA\x77\x14\xE6\x1B\x32\xB0\xF0\xB0\xB3\xEE\x39\xBC\xAD\xE0\x5F\x2E\x54\x68\x04\x3A\xA1\xF0\xC7\x81\x48\x73\xDF\x96\x0A\xF5\x48\x10\x0C\x95\x40\xF8\xE6\xAB\x3D\x5E\xEB\x14\xEC\x1E\xAF\x60\x04\xCE\xB7\x0B\x4E\x2E\x65\x28\x8A\x28\x25\xB8\xC2\x68\x35\x38\x1C\xDB\xE2\xCB\x88\x2C\xA1\x1E\xA3\x6E\x10\x76\xF7\xD6\xAA\xD5\xCF\x87\x61\x38\xEA\xBD\xFF\x42\x92\x26\xFF\x6C\xAD\x95\x89\xF1\xF1\x23\x3B\x66\x77\x3C\xD9\x68\x34\xB6\x03\x45\xAF\xDF\x3B\x79\xE1\xE2\xC5\x2F\xB6\xDB\xED\xA3\x83\x70\xF4\xDE\x13\xD6\x6A\xBB\x77\xCC\xCE\x7E\x64\x62\x62\xE2\x40\x18\x84\xD1\xF4\xD4\xD6\x13\x85\x2D\x46\xFB\xFD\x18\x6B\x2D\xB6\xB0\x2C\x2F\x2F\x51\x14\x45\x6D\xEB\xD4\xD6\xDF\xDA\x36\xBD\xF5\x57\x2A\x95\xCA\x74\xA3\xD1\xE8\xA7\x49\xFA\x72\xAF\xDF\x7B\x5E\x55\xDF\xDC\xF4\x10\xB6\x0A\x4F\xDC\x93\xF1\x4A\xD7\x70\xB2\x1B\x7C\x3C\x32\xCC\x5A\x55\xBE\xF4\xCA\x0A\x88\x70\x25\xB6\x1C\xBF\x9C\xE2\xBC\xF2\x3F\x8B\x31\x0B\x97\x62\x50\x50\x81\x50\x04\x19\xA4\x01\x55\x8C\x08\xAA\x3A\xA1\x2A\x3F\x93\x59\xFF\xE2\x64\xB5\x81\x2B\x9A\x98\xB4\x0D\x10\x14\xD6\xB6\x54\x15\x6B\x8B\xCA\xE5\xCB\x97\x99\xDC\x32\xF9\xA9\xBD\x7B\xF6\x3C\x19\x04\xC1\x20\xD0\x6B\xE3\x63\x63\x0F\x35\xEA\x8D\xF9\x33\x67\xCF\xFE\xE5\xD2\xF2\xD2\x0B\x00\xF5\x7A\xFD\xA1\xBD\xF7\xEE\xF9\x5C\xB3\xD9\x6C\x78\xEF\xB1\xB6\xA0\x5A\xAD\xFE\x42\xA5\x12\xD1\xEF\xF7\xF0\xDE\x93\xA4\x89\x6D\x77\x3A\x95\x9D\x73\x73\x7F\xB5\x6D\x7A\xDB\x01\xDE\x9A\xD3\x58\xBD\x5E\xFF\x60\x10\x04\x0F\x27\x49\xF2\x87\x0A\x67\x37\x15\x40\xA7\x30\x1E\x29\x8F\x4E\xDA\xDD\xC7\x3B\xE1\xFB\x22\x94\xC8\x08\x3F\x5C\xCA\xF8\xC2\xC2\x15\xAA\x81\x10\x18\x59\x05\xED\x1A\x58\x6F\xD5\xC2\x41\x64\xF8\x32\xCF\xF5\x0B\xA5\x1E\xEA\x83\xBF\xB7\x23\x7B\xF1\xE1\x29\x25\xBD\xB2\x8B\xA3\xC7\x8E\x11\xAA\x92\xC4\x31\x61\x18\xD2\x6E\x77\x52\xE7\xDC\xFC\xF6\x99\x99\x27\xD3\x34\xC5\x39\x9B\xA5\x59\xF6\x7D\x54\xC7\xEA\xF5\xFA\xBB\x82\x20\x90\xED\x33\x33\xBF\x1F\xC7\xFD\x1F\xA4\x79\xB6\xB8\x7D\x66\xE6\xB3\x22\x34\x3A\x9D\x0E\x69\x9A\x9E\xB2\xCE\x2E\xD7\xAA\xB5\x03\x51\x14\xD5\xCA\x2A\xAC\xDD\x6E\xCF\x8E\xB5\x5A\xCF\xB6\x46\x47\x0F\xF4\x7A\x5D\xB2\x2C\x7B\x2D\x4D\xD3\x13\x41\x10\xCE\x35\x1A\x8D\xFD\x41\x10\x6C\x1D\x69\x8E\xFC\x81\x73\xFE\xD3\xE5\x74\x37\xAF\x0A\x3B\x85\xB3\xB1\x79\xDC\x40\x65\x50\x52\x42\x03\x89\xF5\x78\x35\x78\x5D\xAD\xBC\x03\xB0\x06\xC0\xE9\x50\xFE\x1F\x48\x8B\x7E\x01\xDB\x6B\x3A\xFB\xFE\xE9\x1C\x11\xA1\xD8\xB6\x8D\x89\x89\x09\xBA\xDD\x2E\x49\x92\x10\x06\x01\x71\xDC\x0F\x1B\xF5\xC6\xE1\x22\xCF\x49\xBD\xD7\x6E\xAF\xFB\x9C\xF3\xFE\xDB\x71\xBF\x4F\x14\x45\xCF\x6E\x9D\xDA\xFA\x3B\x81\x31\xD5\x66\xA3\xF9\xB8\x88\x9C\x11\x64\xA6\xDB\xED\x11\xC7\xF1\x57\x3A\xDD\xCE\x5F\x9B\x20\x20\xCB\xB2\x83\xDB\xB7\xCD\xFC\x45\x25\x8A\x1A\xDE\x7B\xE7\xBD\xDB\xD1\xAC\x8F\xFE\x72\xBF\x1F\x53\x14\x45\xB1\xBC\xB2\xFC\xB2\x73\xEE\x55\x55\x16\xC7\x5A\xAD\xD9\x46\xBD\xDE\x52\x38\x00\x7A\x10\x38\xBA\x59\x00\x8A\x11\x74\x39\x37\xE6\xFB\xED\x60\x3E\x32\x6F\x2D\x8C\x00\x49\xE1\xC9\xAC\xBE\x5D\x16\xE8\xC6\x12\x41\xCB\xA5\x55\x68\x25\x5E\x4C\xC5\xE0\x83\xC0\xB0\x73\xE7\x4E\x7E\x70\xFC\x38\x69\x92\x60\x8C\xC1\x5A\x37\x62\x44\x76\x75\x3A\x1D\x0A\x5B\x1C\x4F\xB3\xEC\xDB\x61\x18\xE2\xBD\xA7\xDB\xEB\xFD\x53\x51\x14\x1F\x00\x19\xF7\xDE\xED\xF5\xAA\xCD\xD7\x2F\x5E\x00\xA5\x70\xDE\xFD\x6B\x10\x04\x44\xC6\x90\xE7\xF9\xB1\x4B\x8B\x97\xBE\x51\xA9\x54\x3F\x28\x82\xCD\x8B\x62\x47\xAF\xDF\x9F\x48\xD2\x14\x23\x12\x35\xEA\x8D\x27\x8C\xC8\xB5\x02\x14\xC7\x31\x88\x90\xA6\xE9\xAE\xCD\x02\x50\x00\x11\x20\x57\xB6\xA4\x5E\xEE\x91\x75\x00\x71\xAA\xC8\x4D\x8B\x82\x55\x5F\x55\x5C\x59\xFD\xD5\x39\xC7\xD4\xD4\x94\x36\x47\x46\x58\xE9\xB4\x57\xF3\xAE\x73\xEA\xBD\xD7\x32\xFC\x02\x11\x19\xD6\x78\x41\x9A\x65\x03\xE5\x10\x8A\x88\x58\x6B\x07\xF3\x0D\xBD\xF7\x14\x45\x81\x31\x86\xBC\x28\xA2\xAC\xC8\x41\xF1\x22\x52\xE4\x79\xBE\x2A\x3B\x8C\xF1\x22\x82\x11\x63\x8C\x31\x3E\x30\xC6\x19\x23\x91\x88\x41\x44\xA2\xCD\xC8\x81\x52\x5A\x50\xDE\xD4\xA4\x6C\x6F\xA4\xFC\xAF\x0B\xA2\x08\xEA\x6D\xB9\xED\x0B\x68\x45\xBA\x1C\x09\x5E\x95\x50\x51\x17\x86\xA1\x4E\x4E\x4E\x72\xFA\xF4\x69\xC2\x30\x04\xE8\x8A\xC8\x8F\x80\x7D\x22\xF2\x00\xF0\x7E\xE0\x6B\x25\xE8\x1F\x13\x91\xD6\xD0\xE8\x27\x44\xE4\x37\xCA\xEF\x78\x1A\xF8\x33\xA0\x00\x7E\x51\x44\x7E\x55\x10\x10\x16\x81\x97\x81\x36\x30\xA1\xAA\x3D\xEF\xFD\xDF\x39\xDC\x29\x60\x0E\xD8\x07\x7C\xC3\x18\xD3\x08\x8C\xB9\xF8\x4E\x01\x1C\x80\x67\x4A\x00\x43\x81\x40\xD0\x14\xA4\x79\xA3\xED\xD3\x35\x20\xA5\x0C\x65\xEF\xF1\x59\x8A\xCF\x62\x50\x4F\x51\x9F\x64\x77\xD3\x9F\xAF\x07\x1A\xC6\x4E\xC2\x32\x84\x7C\xAB\xD5\x5A\xDD\x3D\xAC\xB2\x4D\x81\xAF\x00\x1F\x28\xE7\xF2\x19\xE0\x37\x81\x11\x60\x76\xE8\xB5\x55\xE0\x25\xE0\xC3\xC0\x6E\xE0\xBD\xC0\x7E\xA0\x0B\xDC\x0B\x0C\xD8\xF4\x65\x60\x11\x78\x11\x78\x0A\x68\x89\xC8\xB3\xC0\x69\x60\x07\x30\x0D\xFC\x48\x55\xBF\xA5\x9B\x24\xA4\x07\xEC\xAB\x78\xA5\xD9\x8A\x94\xED\x15\x7B\xC9\xE6\x39\x14\x39\xD8\x1C\x6C\xB1\xC6\x2C\x38\x8B\xDA\x1C\x2D\x32\x7C\x1A\xE3\x7B\x6D\x5C\xE7\x2A\xBE\xB7\x82\xE6\x09\x3E\xE9\x11\xD8\x94\x43\x63\xFE\xB4\x57\x69\x95\x1F\xB8\x1E\xB3\x6B\xC0\x49\xE0\x6F\xCB\xB4\x19\x02\xF7\xAD\x01\x8F\xB2\x7F\x02\x3C\x07\x5C\x2A\x9F\xDD\x53\xFA\x0E\xC0\x7B\xBE\x64\x2F\xC0\xDF\x03\xDF\x2C\xDB\x13\xC0\x43\xC0\x4C\x89\xC1\xAF\x01\x38\xE7\xD8\x0C\x06\x0E\xD8\x17\x29\x34\xEA\x86\xC6\xCF\x6D\x71\x3F\x3E\xB6\x98\x3F\x50\x09\xB4\xCC\x8C\x6B\xBA\xA8\x47\xBD\x03\xEF\xD0\xD2\x70\x0E\x55\x87\x7A\x0F\xAE\x20\x29\x3C\x07\x67\xFD\xD9\x83\x63\xF6\xCD\xCC\x33\x56\x32\xC5\x95\x7B\xD7\xF5\x72\xC0\xBF\x01\xC7\x81\x23\xC0\x4F\x95\xA1\x79\xAA\x6C\x4F\x94\x6D\x80\x1F\x03\x9F\x04\x0E\x03\x0F\x02\x15\xE0\x02\xF0\x75\xE0\x95\xA1\xF1\x72\xE0\x4F\x81\x7F\x07\x7E\x09\x98\x04\xD2\x32\xBC\xBF\xB6\x19\x3B\x11\x59\xCB\x40\xA0\x9E\x79\x26\x1E\x9B\xD6\xD7\xBF\xFE\xAA\xEF\x5C\x68\x27\xAD\x6A\x68\x86\xDC\x14\xB5\x05\xEA\x8A\xA1\x6D\x95\x07\xEF\x51\x67\x57\xC1\xF3\x0E\x5B\x64\x44\x8D\x71\x9E\xDA\x13\x7E\xAF\x6A\x5C\x33\x75\x14\x40\x26\x22\x7D\x11\x61\x65\x65\xE5\xFE\xA1\x79\x2C\x0D\xB5\x4F\x01\x9F\xBF\x89\xEF\x58\x01\xFE\xF1\x66\xB6\xCB\xC0\x77\x4A\xFB\x3F\xD9\x0B\x0F\xE7\xC0\x10\xA8\x38\xA5\x39\x51\xF1\xE1\x47\xEF\xAB\xBC\x62\xD4\xE1\xD2\x3E\xE4\x09\xE4\x31\xBE\xDF\x46\x93\x2E\x14\x29\x14\x29\x9A\x25\x68\xDA\x47\xD3\x1E\x9A\xF5\x21\xEB\x63\xE3\x36\x99\x83\xA7\x0F\xCD\xFC\x70\x7E\xC2\xAF\xA4\x8E\x51\xA0\x22\x22\x26\xCF\xF3\xA9\x93\x27\x4F\x3E\x79\xEE\xDC\xB9\x4F\xAC\xEE\x38\xE8\x03\xFF\xFD\x93\x7E\x22\x2D\x6B\xCC\x24\x96\xEA\xC3\x5B\x59\xFA\xE4\x81\xB1\xB3\xCE\x7B\xB2\xA4\x8F\x4F\xBA\x68\xD6\x43\x6D\x8A\xE6\x29\x9A\xC5\xAB\xC0\xA5\x7D\x7C\x16\xA3\x69\x9F\xA4\xBB\x82\x37\x11\x9F\x78\x64\xDF\x85\x0F\xDD\x1B\x9E\x4B\xAD\x56\x4B\x76\x9B\x20\x08\xD2\x73\xE7\xCE\x3D\x75\xEA\xD4\xA9\x4F\x03\x4D\xE7\x1C\xDE\xFB\xE7\xBD\xF7\x97\xBC\xF7\x78\xEF\xF9\x49\xF8\xCB\x35\xBC\xCE\x29\xD6\x40\xFB\x5A\xA0\x48\xAD\xBA\xC3\x73\xC1\xEB\xAD\xEA\x8C\xF9\xE2\xB1\xAB\xB3\xE7\x17\xAF\x84\x92\x27\x84\xA2\x08\x0A\xDE\xE1\x9D\xC7\x39\x8B\xB5\x0E\x82\x90\xFB\x76\xDE\x53\x3C\xFD\x9E\x5D\x6F\xFC\xEC\xD6\xE0\x42\x6A\xBD\xD3\xD5\x3C\x66\x01\xB7\x7A\x0E\xB0\xAA\xF7\x8C\x31\x4B\x73\x73\x73\xFF\x30\x39\x39\xF9\xD5\x01\x68\x41\x10\x70\xE6\xCC\x19\xAE\x5E\xBD\x4A\xC9\xCE\xFF\x97\xD7\xB5\xE3\xA1\x85\x85\x85\x01\xE3\xC2\x52\x22\x34\x81\xF1\x32\xD9\x4E\x97\xB6\xA5\x16\xC8\xE8\x72\x61\x5A\xFF\xF9\x46\x3A\xF5\xDD\xF3\xED\xB1\xD7\xAE\xB4\x6B\xFD\x38\x31\xCE\x59\x02\x94\xD1\x5A\xC5\xED\x9E\x1E\x4B\x7F\x7E\xCF\x54\xFB\x3D\xB3\x23\x4B\x0D\xE3\xBA\xA9\xD5\x1E\xB0\x0C\xBC\x09\x5C\x9E\x9F\x9F\xFF\xD6\xD1\xA3\x47\x67\x0E\x1D\x3A\x74\xE9\x85\x17\x5E\x78\x6C\x6C\x6C\xEC\xD8\xA3\x8F\x3E\xDA\x5E\xB3\x88\x72\x83\x7B\xD6\xC9\xDF\x1B\x3D\x5F\x8F\x24\x1B\xF9\xE8\x3A\xCF\x37\x3A\xB6\xD4\x70\x1D\x27\x2D\x19\x92\x97\x32\xA1\x57\x16\x14\x03\xB8\xD4\x69\x3A\x12\xB8\xFE\x91\x9D\x95\xA5\xF7\xED\xDC\x56\x69\xE7\xDB\xAA\x9D\xDC\x47\x56\x31\x15\x83\x1F\xAF\x9A\x62\x34\x92\xCC\xA8\x2F\x32\x67\xF3\xD4\x92\x00\x9D\x32\xD1\x2F\x95\xD5\x17\xEF\xBD\x07\x38\x72\xE4\xC8\x4B\x37\x00\x67\x78\x5E\xB2\xC1\x87\xEB\x9A\x22\x78\xBD\x0F\xBF\xDE\xE2\x6C\xD4\xDE\x70\x11\xC3\xF5\x76\x68\xA5\x63\x51\x02\x38\xC8\x93\xB6\x2C\xFB\x5D\xA7\x34\x12\xAB\x55\x70\x95\xD1\x80\x60\xAC\x71\x2D\x5F\xAA\x53\xA7\x59\x81\x1B\xF2\x4F\xCA\xE2\xD0\x29\xAD\x5B\x8E\x97\x0D\xFD\xA1\x25\xF3\xF3\xF3\x77\x22\xE1\xE9\x0D\x58\xB9\x76\x81\x6E\x78\x60\x1E\x6E\x30\x88\x2F\x01\x5C\xCB\xC8\x18\x68\x94\x62\xB7\x52\x56\xE9\xC0\x29\x66\xC8\xD7\x97\xFE\x45\xD9\x67\x00\x62\x5C\x5A\x32\xA4\xCB\x58\x58\x58\x08\xE6\xE7\xE7\xFD\x9A\x09\xDF\xC9\xEA\x21\xB7\xE0\xB7\x36\x1A\x34\xBC\xCE\xC1\x89\x1D\xD2\x4E\x76\x08\xC0\x6A\x09\x5E\x54\x2E\x40\x50\xB2\x74\x18\xC0\x41\x9F\x41\xBF\x6C\xC8\xF2\xC1\x49\xD9\x06\x21\x7B\x2B\x6C\xDA\x28\x9C\x6F\x15\x9C\x4D\xAF\xC2\x0C\xB1\x70\xC0\x28\x5B\x02\x10\x0E\x01\x37\x00\xCF\xAC\x11\xAB\x03\xD6\x0E\xFA\x15\xF3\xF3\xF3\x4B\x0B\x0B\x0B\xCD\xA1\x85\x71\x00\x37\x19\xBA\x7A\x0B\xCC\x91\x4D\x0C\xEB\xDB\x3E\xCE\x1A\x9E\xB0\x5D\x13\x96\x66\x8D\xC9\x3A\x0C\xD0\x35\xE1\xEC\x87\xC2\x56\x6F\x81\x79\xCA\xCD\x55\x43\x6E\x23\x0C\x6F\xF4\xDB\x4D\xBD\x6B\x58\xC6\xDC\x28\x47\xC8\x06\xB6\x51\x08\xE9\x5A\x9B\x9F\x9F\x77\xEB\xC8\x8E\xEB\xB5\x37\x02\x70\x43\x59\x71\x93\xCF\xDF\x89\x8C\x79\x5B\xFB\x7F\x07\x00\x00\xB1\x1B\xB1\x55\x5B\x90\xAA\x00\x00\x00\x00\x49\x45\x4E\x44\xAE\x42\x60\x82";

	size_t length = (sizeof bytes) - 1; //string literals have implicit trailing '\0'
	NSData * datas = [[NSData alloc] initWithBytes:bytes length:length];
	UIImage * myimage = [UIImage imageWithData:datas];
	Image = myimage.CGImage;
	if(Image == NULL) {
		return false;
	}
	
	_nWidth = CGImageGetWidth(Image);
	_nHeight = CGImageGetHeight(Image);	
	if ( _nWidth > _nHeight )
	{
		v = _nWidth;
	}
	else
	{
		v = _nHeight;
	}
	_texSize = 1;
	do
	{
		_texSize *= 2;
		if ( _texSize >= v )  
			break;
	}
	while ( _texSize < 1024  ); 
		
	if(Image) 
	{
		// Allocated memory needed for the bitmap context
		_pData = (GLubyte *) calloc(_texSize * _texSize * 4, sizeof(GLubyte));

		// Uses the bitmap creation function provided by the Core Graphics framework. 
		Context = CGBitmapContextCreate(_pData, _nWidth, _nHeight, 8, _texSize * 4, CGImageGetColorSpace(Image), kCGImageAlphaPremultipliedLast);
		//		Context = CGBitmapContextCreate(_pData, _nWidth, _nHeight, 8, _nWidth * 4, CGImageGetColorSpace(Image), kCGImageAlphaPremultipliedLast);
		
		rx = _texSize;
		ry = _texSize;		
		
		// After you create the context, you can draw the sprite image to the context.
		CGContextDrawImage(Context, CGRectMake(0.0, 0.0, (CGFloat)_nWidth, (CGFloat)_nHeight), Image);
		
		// You don't need the context at this point, so you need to release it to avoid memory leaks.
		CGContextRelease(Context);
		
		glTexImage2D(GL_TEXTURE_2D, 0, GL_RGBA, rx, ry, 0, GL_RGBA, GL_UNSIGNED_BYTE, _pData);
	}
	if(_pData) {
		free(_pData);
		_pData = NULL;
	}
	return true;
}

bool GLTextureHelper::loadText(const char *text, const char * fontname, int fontsize)
{
	if(isEyeRetina() == true) {
		_eyeRetina = true;
		fontsize *= 2;
	}
	NSString * str = [NSString stringWithUTF8String:text];
	NSString * family = [[NSString alloc] initWithFormat:@"%s", fontname];
	UIFont * font = [UIFont fontWithName:family size:fontsize];
	CGSize dimensions = [str sizeWithFont:[UIFont fontWithName:family size:fontsize]];
	NSUInteger width = dimensions.width;
	NSUInteger height = dimensions.height;
	_nWidth = width;
	_nHeight = height;
	long v;
	if ( _nWidth > _nHeight ) {
		v = _nWidth;
	}
	else {
		v = _nHeight;
	}
	_texSize = 1;
	do
	{
		_texSize *= 2;
		if ( _texSize >= v )  
			break;
	}
	while ( _texSize < 1024  );
	
	width = _texSize;
	height = _texSize;
	CGColorSpaceRef colorSpace = CGColorSpaceCreateDeviceGray();	
	void * data = (GLubyte *) calloc(width * height * 1, sizeof(GLubyte));
	CGContextRef context = CGBitmapContextCreate(data, _nWidth, _nHeight, 8, _texSize, colorSpace, kCGImageAlphaNone);	
	CGColorSpaceRelease(colorSpace);
	CGContextSetGrayFillColor(context, 1.0, 1.0);
	CGContextTranslateCTM(context, 0.0, _nHeight);
	CGContextScaleCTM(context, 1.0, -1.0); //NOTE: NSString draws in UIKit referential i.e. renders upside-down compared to CGBitmapContext referential
	UIGraphicsPushContext(context);
	[str drawInRect:CGRectMake(0, 0, _nWidth, _nHeight) withFont:font lineBreakMode:UILineBreakModeWordWrap alignment:UITextAlignmentLeft];
	UIGraphicsPopContext();	
	CGContextRelease(context);
	glTexImage2D(GL_TEXTURE_2D, 0, GL_ALPHA, width, height, 0, GL_ALPHA, GL_UNSIGNED_BYTE, data);
	free(data);
	return true;
}

void GLTextureHelper::listFonts()
{
	// List all fonts on iPhone
	NSArray *familyNames = [[NSArray alloc] initWithArray:[UIFont familyNames]];
	NSArray *fontNames;
	NSInteger indFamily, indFont;
	for (indFamily=0; indFamily<[familyNames count]; ++indFamily)
	{
		NSLog(@"Family name: %@", [familyNames objectAtIndex:indFamily]);
		fontNames = [[NSArray alloc] initWithArray:
					 [UIFont fontNamesForFamilyName:
					  [familyNames objectAtIndex:indFamily]]];
		for (indFont=0; indFont<[fontNames count]; ++indFont)
		{
			NSLog(@"    Font name: %@", [fontNames objectAtIndex:indFont]);
		}
		[fontNames release];
	}
	[familyNames release];
}

bool GLTextureHelper::isEyeRetina()
{
	float version = [[[UIDevice currentDevice] systemVersion] floatValue];
	if(version >= 3.2) 
	{
		UIScreen* mainscr = [UIScreen mainScreen];
		int w = mainscr.currentMode.size.width;
		int h = mainscr.currentMode.size.height;
		if (w == 640 && h == 960) // Retina display detected
		{
			return true;
		}
	}	
	return false;
}

bool GLTextureHelper::LoadTexture(const char *szTextureFile)
{
	//printf("%s\n", szTextureFile);
	// Loads in EyeRetina if available
	_eyeRetina = false;
	if(isEyeRetina() == true) 
	{
		char * Path = (char*)calloc(256, sizeof(char));
		int len = strlen(szTextureFile);
		if(len > 4) {
			strncpy(Path, szTextureFile, len-4);
			strcat(Path, "@2x");
			strcat(Path, szTextureFile+len-4);
			//printf("Path: %s\n", Path);
			bool res = LoadTextureEx(Path);
			if(res == true)
			{
				_eyeRetina = true;
				return true;
			}
		}
	}
	bool res = LoadTextureEx(szTextureFile);
	return res;
}

bool GLTextureHelper::LoadTextureEx(const char *szTextureFile  )
{
	CGImageRef Image;
	CGContextRef Context;
	long   v;
	int rx = 1;
	int ry = 1;
		
	const char *extension = &szTextureFile[strlen(szTextureFile)-3];
	if(!strcmp(extension, "tga")) 
	{
		JadeImage_t tgaImage;
		tgaImage.filename = (char *)szTextureFile;
		int res = LoadFileTGA(&tgaImage);
		if(res == 0) {
			return false;
		}
				
		_nWidth = tgaImage.width;
		_nHeight = tgaImage.height;
		
		if ( _nWidth > _nHeight )
		{
			v = _nWidth;
		}
		else
		{
			v = _nHeight;
		}
		_texSize = 1;
		do
		{
			_texSize *= 2;
			if ( _texSize >= v )  
				break;
		}
		while ( _texSize < 1024  );
		
		rx = _texSize;
		ry = _texSize;		
		
		int pixelSize = tgaImage.bpp/8;
		GLubyte * newSurface = (GLubyte *) calloc(rx * ry * 4, sizeof(GLubyte));
		
		// recopie dans la plus grande surface puissance de 2 notre texture non puissance de 2
		unsigned char R, G, B, A;
        
        A = 0;
        
		for(int i=0 ; i<tgaImage.width ; i++)
		{
			for(int j=0 ; j<tgaImage.height ; j++)
			{
				int pos = (i + (tgaImage.width * j))*pixelSize;
				int pos2 = (i + (rx * (tgaImage.height-j-1)))*4;
				
				R = tgaImage.pixels[(pos)+0];
				G = tgaImage.pixels[(pos)+1];
				B = tgaImage.pixels[(pos)+2];
				if(pixelSize == 3)
				{
					A = 255;
				}
				else if(pixelSize == 4)
				{
					A = tgaImage.pixels[(pos)+3];
				}
				
				newSurface[(pos2)+0] = (GLubyte)R;
				newSurface[(pos2)+1] = (GLubyte)G;
				newSurface[(pos2)+2] = (GLubyte)B;
				newSurface[(pos2)+3] = (GLubyte)A;
				
				//printf("%d %d %d %d\n", (int)R, (int)G, (int)B, (int)A);
			}		
		}
		
		_pData = newSurface;
		_nWidth = rx;
		_nHeight = ry;	
		free(tgaImage.pixels);
	}
	else
	{			
		NSString * stringFromChar = [NSString stringWithCString:szTextureFile encoding:NSUTF8StringEncoding]; 
		UIImage * myimage = [UIImage imageNamed:stringFromChar];		
		Image = myimage.CGImage;
		if(Image == NULL) {
			return false;
		}
	//	CGRect f = myimage.frame;
	//	NSLog(@"%d %d", f.size.width)
		
		// Get the width and height of the image
		_nWidth = CGImageGetWidth(Image);
		_nHeight = CGImageGetHeight(Image);
	
		// Texture dimensions must be a power of 2. If you write an application that allows users to supply an image,
		// you'll want to add code that checks the dimensions and takes appropriate action if they are not a power of 2.
		
		if ( _nWidth > _nHeight )
		{
			v = _nWidth;
		}
		else
		{
			v = _nHeight;
		}
		_texSize = 1;
		do
		{
			_texSize *= 2;
			if ( _texSize >= v )  
				break;
		}
		while ( _texSize < 2048  ); 
		
		if(Image == NULL) {
			return false;
		}
		
		// Allocated memory needed for the bitmap context
		_pData = (GLubyte *) calloc(_texSize * _texSize * 4, sizeof(GLubyte));
			
		// Uses the bitmap creation function provided by the Core Graphics framework. 
		Context = CGBitmapContextCreate(_pData, _nWidth, _nHeight, 8, _texSize * 4, CGImageGetColorSpace(Image), kCGImageAlphaPremultipliedLast);

		rx = _texSize;
		ry = _texSize;		
			
		// After you create the context, you can draw the sprite image to the context.
		CGContextDrawImage(Context, CGRectMake(0.0, 0.0, (CGFloat)_nWidth, (CGFloat)_nHeight), Image);

		// You don't need the context at this point, so you need to release it to avoid memory leaks.
		CGContextRelease(Context);
	}
	
	// Specify a 2D texture image, providing the a pointer to the image data in memory
	glTexImage2D(GL_TEXTURE_2D, 0, GL_RGBA, rx, ry, 0, GL_RGBA, GL_UNSIGNED_BYTE, _pData);
	
	if(_pData) {
		free(_pData);
		//delete [] _pData ;
		_pData = NULL ;
	}
	return true;
}

int GLTextureHelper::LoadFileTGA(JadeImage_t *textureObject)
{    
	unsigned char		*imageData;									// Image Data (Up To 32 Bits)
	int					bpp;										// Image Color Depth In Bits Per Pixel.
	int					width;										// Image Width
	int					height;										// Image Height
	unsigned char		TGAheader[12] =		{0,0,2,0,0,0,0,0,0,0,0,0};	// Uncompressed TGA Header
	unsigned char		cTGAheader[12] =	{0,0,10,0,0,0,0,0,0,0,0,0};	// Compressed TGA Header
	unsigned char		TGAcompare[12];								// Used To Compare TGA Header
	unsigned char		header[6];									// First 6 Useful Bytes From The Header
	unsigned int		bytesPerPixel;								// Holds Number Of Bytes Per Pixel Used In The TGA File
	unsigned int		imageSize;									// Used To Store The Image Size When Setting Aside Ram
	int					temp;										// Temporary Variable
	
	if(textureObject == 0) {
		return 0;
	}
	
	//Texture_t textureObject;
	textureObject->width = 0;
	textureObject->height = 0;
	textureObject->bpp = 0;
	textureObject->pixels = 0;
	
	char	*file_path = KMiscTools::makeFilePath(textureObject->filename);
	FILE *file = fopen(file_path, "rb");
	if(	file==NULL )
	{
		return 0;
	}
	if( fread(TGAcompare,1,sizeof(TGAcompare),file)!=sizeof(TGAcompare) )	// Are There 12 Bytes To Read?
	{
		return 0;
	}
	
	bool is_compressed = false;
	
	if(memcmp(TGAheader, &TGAcompare, sizeof(TGAcompare)) == 0)				// See if header matches the predefined header of 
	{																		// an Uncompressed TGA image
		is_compressed = false;
	}
	else if(memcmp(cTGAheader, &TGAcompare, sizeof(TGAcompare)) == 0)		// See if header matches the predefined header of
	{																		// an RLE compressed TGA image
		is_compressed = true;
	}
	else																	// If header matches neither type
	{
		//logfile->logDebug("TGA file be type 2 or type 10\n");
		return 0;
	}
	
	if(is_compressed == true)
	{
		// compressed TGA loading -------------------
		
		if(	fread(header,1,sizeof(header),file)!=sizeof(header))				// If So Read Next 6 Header Bytes
		{
			if (file == NULL)									// Did The File Even Exist? *Added Jim Strong*
				return 0;									// Return False
			else
			{
				fclose(file);									// If Anything Failed, Close The File
				return 0;									// Return False
			}
		}
		
		width	= header[1] * 256 + header[0];					// Determine The TGA Width	(highbyte*256+lowbyte)
		height	= header[3] * 256 + header[2];					// Determine The TGA Height	(highbyte*256+lowbyte)
		bpp		= header[4];										// Determine Bits Per Pixel
		
		if(	width	<=0	||								// Is The Width Less Than Or Equal To Zero
		   height	<=0	||								// Is The Height Less Than Or Equal To Zero
		   (header[4]!=24 && header[4]!=32))					// Is The TGA 24 or 32 Bit?
		{
			fclose(file);										// If Anything Failed, Close The File
			return 0;										// Return False
		}
		
		bytesPerPixel	= (bpp / 8);									// Compute BYTES per pixel
		imageSize		= (bytesPerPixel * width * height);		// Compute amout of memory needed to store image
		imageData		= (unsigned char *)malloc(imageSize);					// Allocate that much memory
		
		if(imageData == NULL)											// If it wasnt allocated correctly..
		{
			//logfile->logDebug("Could not allocate memory for image\n");
			fclose(file);
			return 0;
		}
		
		unsigned int pixelcount	= height * width;							// Nuber of pixels in the image
		unsigned int currentpixel	= 0;												// Current pixel being read
		unsigned int currentbyte	= 0;												// Current byte 
		unsigned char * colorbuffer = (unsigned char *)malloc(bytesPerPixel);			// Storage for 1 pixel
		do
		{
			unsigned char chunkheader = 0;											// Storage for "chunk" header
			if(fread(&chunkheader, sizeof(unsigned char), 1, file) == 0)				// Read in the 1 byte header
			{
				//logfile->logDebug("Could not read RLE header\n");
				if(file != NULL)												// If file is open
				{
					fclose(file);												// Close file
				}
				if(imageData != NULL)									// If there is stored image data
				{
					free(imageData);									// Delete image data
				}
				return 0;													// Return failed
			}
			if(chunkheader < 128)												// If the ehader is < 128, it means the that is the number of RAW color packets minus 1
			{																	// that follow the header
				chunkheader++;													// add 1 to get number of following color values
				for(short counter = 0; counter < chunkheader; counter++)		// Read RAW color values
				{
					if(fread(colorbuffer, 1, bytesPerPixel, file) != bytesPerPixel) // Try to read 1 pixel
					{
						//logfile->logDebug("Could not read image data\n");
						if(file != NULL)													// See if file is open
						{
							fclose(file);													// If so, close file
						}
						if(colorbuffer != NULL)												// See if colorbuffer has data in it
						{
							free(colorbuffer);												// If so, delete it
						}
						if(imageData != NULL)										// See if there is stored Image data
						{
							free(imageData);										// If so, delete it too
						}
						return 0;														// Return failed
					}
					imageData[currentbyte		] = colorbuffer[2];				    // Flip R and B vcolor values around in the process 
					imageData[currentbyte + 1	] = colorbuffer[1];
					imageData[currentbyte + 2	] = colorbuffer[0];
					if(bytesPerPixel == 4)												// if its a 32 bpp image
					{
						imageData[currentbyte + 3] = colorbuffer[3];				// copy the 4th byte
					}
					currentbyte += bytesPerPixel;										// Increase thecurrent byte by the number of bytes per pixel
					currentpixel++;															// Increase current pixel by 1
					if(currentpixel > pixelcount)											// Make sure we havent read too many pixels
					{
						//logfile->logDebug("Too many pixels read\n");
						if(file != NULL)													// If there is a file open
						{
							fclose(file);													// Close file
						}	
						if(colorbuffer != NULL)												// If there is data in colorbuffer
						{
							free(colorbuffer);												// Delete it
						}
						if(imageData != NULL)										// If there is Image data
						{
							free(imageData);										// delete it
						}
						return 0;														// Return failed
					}
				}
			}
			else																			// chunkheader > 128 RLE data, next color reapeated chunkheader - 127 times
			{
				chunkheader -= 127;															// Subteact 127 to get rid of the ID bit
				if(fread(colorbuffer, 1, bytesPerPixel, file) != bytesPerPixel)		// Attempt to read following color values
				{	
					//logfile->logDebug("Could not read from file\n");
					if(file != NULL)														// If thereis a file open
					{
						fclose(file);														// Close it
					}
					if(colorbuffer != NULL)													// If there is data in the colorbuffer
					{
						free(colorbuffer);													// delete it
					}
					if(imageData != NULL)											// If thereis image data
					{
						free(imageData);											// delete it
					}
					return 0;															// return failed
				}
				
				for(short counter = 0; counter < chunkheader; counter++)					// copy the color into the image data as many times as dictated 
				{																			// by the header
					imageData[currentbyte		] = colorbuffer[2];					// switch R and B bytes areound while copying
					imageData[currentbyte + 1	] = colorbuffer[1];
					imageData[currentbyte + 2	] = colorbuffer[0];
					if(bytesPerPixel == 4)												// If TGA images is 32 bpp
					{
						imageData[currentbyte + 3] = colorbuffer[3];				// Copy 4th byte
					}
					currentbyte += bytesPerPixel;										// Increase current byte by the number of bytes per pixel
					currentpixel++;															// Increase pixel count by 1
					if(currentpixel > pixelcount)											// Make sure we havent written too many pixels
					{
						//logfile->logDebug("Too many pixels read\n");			// if there is too many... Display an error!
						if(file != NULL)													// If there is a file open
						{
							fclose(file);													// Close file
						}	
						if(colorbuffer != NULL)												// If there is data in colorbuffer
						{
							free(colorbuffer);												// Delete it
						}
						if(imageData != NULL)										// If there is Image data
						{
							free(imageData);										// delete it
						}
						return 0;														// Return failed
					}
				}
			}
		}
		while(currentpixel < pixelcount);													// Loop while there are still pixels left
	}
	else
	{
		// uncompressed TGA loading ------------------
		
		if(	fread(header,1,sizeof(header),file)!=sizeof(header))				// If So Read Next 6 Header Bytes
		{
			if (file == NULL)									// Did The File Even Exist? *Added Jim Strong*
				return 0;									// Return False
			else
			{
				fclose(file);									// If Anything Failed, Close The File
				return 0;									// Return False
			}
		}
		
		width  = header[1] * 256 + header[0];			// Determine The TGA Width	(highbyte*256+lowbyte)
		height = header[3] * 256 + header[2];			// Determine The TGA Height	(highbyte*256+lowbyte)
		
		if(	width	<=0	||								// Is The Width Less Than Or Equal To Zero
		   height	<=0	||								// Is The Height Less Than Or Equal To Zero
		   (header[4]!=24 && header[4]!=32))					// Is The TGA 24 or 32 Bit?
		{
			fclose(file);										// If Anything Failed, Close The File
			return 0;										// Return False
		}
		
		bpp	= header[4];							// Grab The TGA's Bits Per Pixel (24 or 32)
		bytesPerPixel	= bpp/8;						// Divide By 8 To Get The Bytes Per Pixel
		imageSize		= width*height*bytesPerPixel;	// Calculate The Memory Required For The TGA Data
		
		imageData=(unsigned char *)malloc(imageSize);		// Reserve Memory To Hold The TGA Data
		
		if(	imageData==NULL ||							// Does The Storage Memory Exist?
		   fread(imageData, 1, imageSize, file)!=imageSize)	// Does The Image Size Match The Memory Reserved?
		{
			if(imageData!=NULL)						// Was Image Data Loaded
				free(imageData);						// If So, Release The Image Data
			
			fclose(file);										// Close The File
			return 0;										// Return False
		}
	/*
		for(int m=0 ; m<imageSize ; m++)
		{
			unsigned char c = imageData[m];
			printf("%d ", (int)c);
		}*/
	
		for(unsigned int i=0; i<imageSize; i+=bytesPerPixel)		// Loop Through The Image Data
		{														// Swaps The 1st And 3rd Bytes ('R'ed and 'B'lue)
			temp=imageData[i];							// Temporarily Store The Value At Image Data 'i'
			imageData[i] = imageData[i + 2];	// Set The 1st Byte To The Value Of The 3rd Byte
			imageData[i + 2] = temp;					// Set The 3rd Byte To The Value In 'temp' (1st Byte Value)
		}
	}
	
	fclose (file);
	
	textureObject->originalWidth = width;
	textureObject->originalHeight = height;	
	textureObject->width = width;
	textureObject->height = height;
	textureObject->bpp = bpp;
	textureObject->pixels = imageData;
	
	return 1;		
}

